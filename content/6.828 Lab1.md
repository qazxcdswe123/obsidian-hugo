---
aliases: []
link: []
date created: Sep 12th, 2023
date modified: Sep 12th, 2023
---

## ç¯å¢ƒæ­å»º
å…¶å®æ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œç”¨ Linux å¾ˆç†Ÿäº†ï¼Œåœ¨ Debian ä¸Šè·Ÿæ­¥éª¤ `apt install` å°±è¡Œäº† (Iâ€™m not using arch btw)  
ç›²çŒœå¾ˆå¤šäººä¼šå¡åœ¨ `git clone`  
æˆ‘ç”¨çš„æ˜¯ 2020 ç‰ˆå› ä¸ºæˆ‘å·²ç»åšè¿‡äº† ğŸ¤£ï¼Œå†å›å‘³äº†ä¸€é

## è§£é¢˜æ€è·¯
è¸©çš„ä¸€ä¸ªå‘æ˜¯å¤´æ–‡ä»¶æœ‰ä¾èµ–å…³ç³»ï¼Œå¿…é¡»å®‰è£…é¡ºåº `include`, (linker is awesome btw), ç„¶å `clang-format` è‡ªåŠ¨ç»™æˆ‘ `SortInclude` æå¾—æˆ‘è«åå…¶å¦™ä¼šå¤±è´¥ï¼Œæ±—  
è¿˜æœ‰å°±æ˜¯ VSCode Makefile Extension ä¼šå¯¼è‡´ include æœ‰é—®é¢˜ï¼Œå¾ˆè¿·

### sleep
å±äºæ˜¯ç»ƒæ‰‹é¢˜ï¼Œè®©ä½ çŸ¥é“æ€ä¹ˆåŠ  user program  
ç„¶åçŸ¥é“ `argc`, `argv`, è½¬æ¢ `string` åˆ° `int` å°±è¡Œäº†ï¼Ÿ

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int
main (int argc, char **argv)
{
  if (argc < 2)
    {
      printf ("usage: sleep <ticks>\n");
    }
  sleep (atoi (argv[1]));
  exit (0);
}
```

### pingpong
`pipe` ç»ƒæ‰‹é¢˜ï¼Œè¦çŸ¥é“ `fork` and `pipe` çš„ç”¨æ³•ï¼Œ`read`, `write`, `fd`, `parent` and `child`  
ç»å…¸ IPC btw

> TheÂ `wait(0)`Â function is a system call that suspends the execution of the calling process until one of its child processes terminates or a signal is received.

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int
main (int argc, char const *argv[])
{
  // index 0 -> in, 1 -> out, like fd 0 1 2
  int p2c[2], c2p[2];
  pipe (p2c); // from parent to child
  pipe (c2p); // from child to parent

  if (fork () != 0)
    { // parent
      write (p2c[1], "ping", 4);
      char readin_buf[4];
      read (c2p[0], readin_buf, 4);
      printf ("%d: received pong\n", getpid ());
      wait (0); // wait for child to finish
    }
  else
    {
      char readin_buf[4];
      read (p2c[0], readin_buf, 4);
      printf ("%d: received ping\n", getpid ());
      write (c2p[1], readin_buf, 4);
    }

  exit(0);
}

```

```
$ pingpong
4: received ping
3: received pong
```

### prime
è¿™ä¸ªè¿˜æ˜¯éå¸¸æœ‰æ„æ€æœ‰éš¾åº¦çš„ï¼Œå’Œ `MapReduce` æœ‰ç‚¹åƒï¼Œåˆå’Œ `functional programming` ä¸­çš„ `filter` æœ‰ç‚¹åƒ  
ä¸­æ–‡æ–‡æ¡£å†™çš„ä¸å¤ªå¥½ï¼Œæ²¡æœ‰å¾ˆä½“ç° **ç­› (sieve)**
- [Sieve of Eratosthenes - Wikipedia](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)

ç”¨ `-1` ä½œä¸º sentinel to indicate the end of input

ç¬¬ä¸€æ¬¡æ²¡åšå‡ºæ¥ï¼Œå†åšäº†ä¸€æ¬¡  
è¦æ³¨æ„å…³ `fd` ä¸ç„¶ä¼šè«åå…¶å¦™çˆ†æ‰ï¼ŒæŸ¥ç½‘ä¸Šçœ‹åˆ°çš„ï¼Œæ±—  
æœ‰æ—¶å€™ä¼šçº ç»“è¦ä¸è¦ `return`, `exit` ï¼Œä¸è¿‡æ„Ÿè§‰é‡ç‚¹æ˜¯ `wait`

```C
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

void
sieve (int p_left[2])
{
  // the 1st input is guaranteed to be prime since non-primes are filterd out
  int init_prime;
  read (p_left[0], &init_prime, sizeof (init_prime));
  if (init_prime == -1)
    {
      exit (0);
    }

  printf ("prime %d\n", init_prime);

  int p_right[2];
  pipe (p_right);

  if (fork () == 0)
    {
      // child
      close (p_left[0]);
      close (p_right[1]);
      sieve (p_right);
    }
  else
    {
      // parent
      close (p_right[0]);
      int i;
      while (read (p_left[0], &i, sizeof (i)) && i != -1)
        {
          if (i % init_prime != 0)
            {
              write (p_right[1], &i, sizeof (i));
            }
        }
      i = -1;
      write (p_right[1], &i, sizeof (i));

      wait (0);
    }
}

int
main (int argc, char const *argv[])
{
  int p[2];
  pipe (p);

  if (fork () == 0)
    { // child
      close (p[1]);
      sieve (p);
    }
  else
    {               // parent
      close (p[0]); // parent no need to read
      int i;
      for (i = 2; i <= 35; i++)
        {
          write (p[1], &i, sizeof (i));
        }
      i = -1;
      write (p[1], &i, sizeof (i));
      wait (0);
    }

  exit (0);
}
```

### find
æœ€æ— èŠçš„ä¸€ä¸ªï¼Œç…§æŠ„å°±æœ‰  
second thoughtï¼š å†™é”™äº†ï¼Œå®³å¾—åé¢ xargs test ä¹Ÿé”™äº†,ğŸ’©

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/fs.h"

void
find (char *path, char *target)
{
  char buf[512], *p;
  int fd;
  struct dirent de;
  struct stat st;

  if ((fd = open (path, 0)) < 0)
    {
      fprintf (2, "find: cannot open %s\n", path);
      return;
    }

  if (fstat (fd, &st) < 0)
    {
      fprintf (2, "find: cannot stat %s\n", path);
      close (fd);
      return;
    }

  switch (st.type)
    {
    case T_FILE:
      if (strcmp (path + strlen (path) - strlen (target), target) == 0)
        {
          printf ("%s\n", path);
        }
      break;
    case T_DIR:
      if (strlen (path) + 1 + DIRSIZ + 1 > sizeof buf)
        {
          printf ("find: path too long\n");
          break;
        }
      strcpy (buf, path);
      p = buf + strlen (buf);
      *p++ = '/';
      while (read (fd, &de, sizeof (de)) == sizeof (de))
        {
          if (de.inum == 0)
            continue;
          memmove (p, de.name, DIRSIZ);
          p[DIRSIZ] = 0;
          if (stat (buf, &st) < 0)
            {
              printf ("find: cannot stat %s\n", buf);
              continue;
            }

          // omit . and ..
          if (strcmp (buf + strlen (buf) - 2, "/.") != 0
              && strcmp (buf + strlen (buf) - 3, "/..") != 0)
            {
              find (buf, target); // recursive find
            }
        }
      break;
    }
  close (fd);
}

int
main (int argc, char *argv[])
{
  if (argc < 3)
    {
      exit (0);
    }
  char target[512];
  target[0] = '/';
  strcpy (target + 1, argv[2]);
  find (argv[1], target);
  exit (0);
}
```

### xargs
æœ€çƒ¦äººçš„ä¸€ä¸ªï¼Œè«åå…¶å¦™ä¼šæŠ¥é”™ï¼Œgdb ä¹Ÿæ²¡è°ƒå‡ºæ¥ï¼Œçœ‹å…¶ä»–äººæ‰å‘ç°ç†è§£é”™ xargs äº† (å¥½åƒæ˜¯å†™é”™ find äº†ï¼Ÿidk)  
ä¹‹å‰æ²¡å†™å‡ºæ¥ï¼Œå°è¯•åˆé‡å†™äº†ä¸€æ¬¡  
ä¸»è¦éš¾ç‚¹æ˜¯å­—ç¬¦ä¸²å¤„ç†ï¼Œå’Œç†è§£ xargs

```c
#include "kernel/param.h"
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

// definitely not very readline but it suit the case
char *
readline (char *buf)
{
  char *pos = buf;
  while (read (0, pos, 1) != 0)
    {
      if (*pos == '\n' || *pos == '\0')
        {
          *pos = '\0';
          return pos;
        }
      pos++;
    }
  return 0;
}

void
run (char *program, char *argv[])
{
  if (fork () == 0)
    { // child
      exec (program, argv);
    }
  else
    {
      wait (0);
    }
}

int
main (int argc, char *argv[])
{
  char *program = argv[1];
  char *args[MAXARG];
  char readin_buf[2048];

  args[0] = program;
  int i = 1;
  // 0 is xargs, 1 is program, first arg starts at 2
  // this is tricky and ugly but it works so whatever
  while (i < argc - 1)
    {
      args[i] = argv[i + 1];
      i++;
    }

  char *str_end = readline (readin_buf);
  while (str_end != 0)
    {
      args[i] = readin_buf;
      i++;
      str_end = readline (str_end + 1);
    }
  args[i] = 0;

  run (program, args);
  exit (0);
}
```

## å®éªŒå¿ƒå¾—
æ°´å¹³æ¯”ç¬¬ä¸€æ¬¡åšçš„æ—¶å€™æå‡äº†ï¼Œèƒ½å†™å‡ºæ¥äº†ğŸ˜‚
æ€»ä½“å†™çš„ååˆ†å¼€å¿ƒ  
æˆ–è®¸å¯ä»¥åŠ ä¸ª gdb å®éªŒï¼Ÿè™½ç„¶ `printf` ä¹Ÿå¾ˆå¤Ÿäº†  
sieve çš„ä¸­æ–‡æ–‡æ¡£ä¸å¤ªè¡Œ
gnu c codestyle æ˜¯çœŸçš„ä¸‘
å¥½åƒæ¯”è¾ƒéº»æœ¨

`make grade` ä¼¼ä¹æ²¡æåˆ°ï¼Ÿ

```
== Test sleep, no arguments == 
$ make qemu-gdb
sleep, no arguments: OK (3.3s) 
== Test sleep, returns == 
$ make qemu-gdb
sleep, returns: OK (1.4s) 
== Test sleep, makes syscall == 
$ make qemu-gdb
sleep, makes syscall: OK (1.2s) 
== Test pingpong == 
$ make qemu-gdb
pingpong: OK (1.1s) 
== Test primes == 
$ make qemu-gdb
primes: OK (1.2s) 
== Test find, in current directory == 
$ make qemu-gdb
find, in current directory: OK (1.3s) 
== Test find, recursive == 
$ make qemu-gdb
find, recursive: OK (1.8s) 
== Test xargs == 
$ make qemu-gdb
xargs: OK (1.6s) 
== Test time == 
time: OK 
Score: 100/100
```